package net.runelite.client.plugins.devtools;import lombok.Data;import lombok.EqualsAndHashCode;import net.runelite.api.*;import net.runelite.api.coords.LocalPoint;import net.runelite.api.coords.WorldPoint;import net.runelite.api.events.ProjectileMoved;import net.runelite.client.eventbus.EventBus;import net.runelite.client.eventbus.Subscribe;import net.runelite.client.ui.ColorScheme;import net.runelite.client.ui.DynamicGridLayout;import net.runelite.client.ui.FontManager;import net.runelite.client.util.ImageUtil;import org.apache.commons.lang3.tuple.Pair;import javax.inject.Inject;import javax.swing.*;import javax.swing.border.CompoundBorder;import java.awt.*;import java.awt.datatransfer.Clipboard;import java.awt.datatransfer.StringSelection;import java.awt.event.*;import java.util.*;import java.util.List;/** * @author Kris | 21/10/2021 */@SuppressWarnings("DuplicatedCode")public class ProjectileInspector extends DevToolsFrame {    private final static int MAX_LOG_ENTRIES = 10_000;    private final Set<Projectile> inspectedProjectiles = Collections.synchronizedSet(new HashSet<>());    private final Map<EarlyProjectileInfo, List<Pair<DynamicProjectileInfo, Pair<JLabel, JButton>>>> trackedProjectiles =            Collections.synchronizedMap(new HashMap<>());    private final Map<EarlyProjectileInfo, Integer> identifiedProjectiles = Collections.synchronizedMap(new HashMap<>());    private final Client client;    private final EventBus eventBus;    private final ImageIcon completeIcon = new ImageIcon(ImageUtil.loadImageResource(getClass(), "complete_copy.png"));    private final ImageIcon incompleteIcon = new ImageIcon(ImageUtil.loadImageResource(getClass(), "incomplete_copy.png"));    private final JPanel tracker = new JPanel();    private final JCheckBox showPlayers = new JCheckBox("Show from players", true);    private final JCheckBox showNpcs = new JCheckBox("Show from NPCs", true);    private final JCheckBox showUnknowns = new JCheckBox("Show from unknown", true);    private int lastTick = 0;    @Inject    ProjectileInspector(Client client, EventBus eventBus) {        this.client = client;        this.eventBus = eventBus;        setTitle("Projectile Inspector");        setLayout(new BorderLayout());        tracker.setLayout(new DynamicGridLayout(0, 1, 0, 3));        final JPanel trackerWrapper = new JPanel();        trackerWrapper.setLayout(new BorderLayout());        trackerWrapper.add(tracker, BorderLayout.NORTH);        final JScrollPane trackerScroller = new JScrollPane(trackerWrapper);        trackerScroller.setPreferredSize(new Dimension(1200, 400));        final JScrollBar vertical = trackerScroller.getVerticalScrollBar();        vertical.addAdjustmentListener(new AdjustmentListener() {            int lastMaximum = actualMax();            private int actualMax()            {                return vertical.getMaximum() - vertical.getModel().getExtent();            }            @Override            public void adjustmentValueChanged(AdjustmentEvent e) {                if (vertical.getValue() >= lastMaximum) {                    vertical.setValue(actualMax());                }                lastMaximum = actualMax();            }        });        add(trackerScroller, BorderLayout.CENTER);        final JPanel trackerOpts = new JPanel();        trackerOpts.setLayout(new FlowLayout());        trackerOpts.add(showPlayers);        trackerOpts.add(showNpcs);        trackerOpts.add(showUnknowns);        final JButton clearBtn = new JButton("Clear");        clearBtn.addActionListener(e -> {            tracker.removeAll();            tracker.revalidate();        });        trackerOpts.add(clearBtn);        final JButton clearCacheBtn = new JButton("Clear cache");        clearCacheBtn.addActionListener(e -> {            inspectedProjectiles.clear();            trackedProjectiles.clear();            identifiedProjectiles.clear();            tracker.removeAll();            tracker.revalidate();        });        trackerOpts.add(clearCacheBtn);        add(trackerOpts, BorderLayout.SOUTH);        tracker.add(new JLabel("The projectile inspector will require each unique projectile to be received from two different distances" +                " in order for it to be able to identify all of the projectile parameters."));        tracker.add(new JLabel("This is due to one of the properties of projectile being the equivalent of (lengthAdjustment + (chebyshevDistance * " +                "stepMultiplier))."));        pack();    }    private void addEntry(EarlyProjectileInfo earlyProjectile, DynamicProjectileInfo dynamicInfo, String prefix) {        int tick = client.getTickCount();        SwingUtilities.invokeLater(() -> {            if (tick != lastTick) {                lastTick = tick;                JLabel header = new JLabel("Tick " + tick);                header.setFont(FontManager.getRunescapeSmallFont());                header.setBorder(new CompoundBorder(                        BorderFactory.createMatteBorder(0, 0, 1, 0, ColorScheme.LIGHT_GRAY_COLOR),                        BorderFactory.createEmptyBorder(3, 6, 0, 0)                ));                tracker.add(header);            }            Integer identifiedProjectileDuration = identifiedProjectiles.get(earlyProjectile);            if (identifiedProjectileDuration == null) {                /* Check if this projectile already has information on it, if so, we can provide in-depth values for that projectile. */                List<Pair<DynamicProjectileInfo, Pair<JLabel, JButton>>> existingDynamicInfos = trackedProjectiles.computeIfAbsent(earlyProjectile,                        k -> new ArrayList<>());                Optional<Pair<DynamicProjectileInfo, Pair<JLabel, JButton>>> diffDistanceInfo =                        existingDynamicInfos.stream().filter(dynamicProjectileInfo -> dynamicProjectileInfo.getLeft().distance != dynamicInfo.distance).findFirst();                JLabel jLabel = new JLabel(prefix + formatIncompleteProjectileEntry(earlyProjectile, dynamicInfo));                jLabel.setLayout(new BorderLayout());                existingDynamicInfos.add(Pair.of(dynamicInfo, Pair.of(jLabel, addJButton(jLabel, true))));                tracker.add(jLabel);                if (diffDistanceInfo.isPresent()) {                    DynamicProjectileInfo existingDynamicInfo = diffDistanceInfo.get().getLeft();                    final int distanceDiff = dynamicInfo.distance - existingDynamicInfo.distance;                    final int durationDiff = dynamicInfo.flightDuration - existingDynamicInfo.flightDuration;                    final int durationPerTileDistance = Math.abs(durationDiff / distanceDiff);                    identifiedProjectiles.put(earlyProjectile, durationPerTileDistance);                    /* Update all the existing labels, including the most recent one, with their identified values. */                    existingDynamicInfos.forEach(dynamicProjectileInfoJLabelPair -> {                        DynamicProjectileInfo existingInfo = dynamicProjectileInfoJLabelPair.getLeft();                        Pair<JLabel, JButton> existingJPair = dynamicProjectileInfoJLabelPair.getRight();                        JLabel existingLabel = existingJPair.getLeft();                        JButton existingButton = existingJPair.getRight();                        existingButton.setIcon(completeIcon);                        existingLabel.setText(prefix + formatFullProjectileEntry(earlyProjectile, existingInfo, durationPerTileDistance));                        updateJButtonListener(existingButton, existingLabel);                    });                    /* Since identified projectile now tracks this, we no longer need to keep a hold of these projectiles. */                    trackedProjectiles.remove(earlyProjectile);                }            } else {                JLabel jLabel = new JLabel(prefix + formatFullProjectileEntry(earlyProjectile, dynamicInfo, identifiedProjectileDuration));                jLabel.setLayout(new BorderLayout());                addJButton(jLabel, false);                tracker.add(jLabel);            }            // Cull very old stuff            while (tracker.getComponentCount() > MAX_LOG_ENTRIES)            {                tracker.remove(0);            }            tracker.revalidate();        });    }    private JButton addJButton(JLabel label, boolean incomplete) {        final JButton button = new JButton(incomplete ? incompleteIcon : completeIcon);        button.setFocusPainted(false);        updateJButtonListener(button, label);        label.add(button, BorderLayout.EAST);        return button;    }    private void updateJButtonListener(JButton button, JLabel label) {        String textToCopy = label.getText().substring(label.getText().indexOf("Projectile("));        Arrays.stream(button.getActionListeners()).forEach(button::removeActionListener);        button.addActionListener(e -> {            StringSelection stringSelection = new StringSelection(textToCopy);            Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();            clipboard.setContents(stringSelection, null);        });    }    @Subscribe    public void onProjectileMoved(ProjectileMoved event) {        Projectile projectile = event.getProjectile();        /* No need to run the calculations for every tick that the projectile moves - just the first, on spawn, is enough. */        if (!inspectedProjectiles.add(projectile)) return;        LocalPoint destinationPoint = event.getPosition();        int localSrcPointX = projectile.getX1();        int localSrcPointY = projectile.getY1();        LocalPoint sourcePoint = new LocalPoint(localSrcPointX, localSrcPointY);        int tileHeight = Perspective.getTileHeight(client, sourcePoint, projectile.getFloor());        int currentCycle = client.getGameCycle();        int startCycle = projectile.getStartMovementCycle() - currentCycle;        int endCycle = projectile.getEndCycle() - currentCycle;        int id = projectile.getId();        int startHeight = -((projectile.getHeight() - tileHeight) / 4);        int endHeight = projectile.getEndHeight() / 4;        int angle = projectile.getSlope();        int distOffset = projectile.getStartHeight();        EarlyProjectileInfo earlyProjectile = new EarlyProjectileInfo(id, startHeight, endHeight, angle, distOffset, startCycle);        DynamicProjectileInfo dynamicInfo = new DynamicProjectileInfo(sourcePoint, destinationPoint, endCycle - startCycle);        WorldPoint sourceWorldPoint = WorldPoint.fromLocal(client, sourcePoint);        WorldPoint destWorldPoint = WorldPoint.fromLocal(client, destinationPoint);        Optional<Player> sourcePlayer = client.getPlayers().stream().filter(player -> player.getWorldLocation().distanceTo(sourceWorldPoint) == 0).findAny();        Optional<NPC> sourceNpc = client.getNpcs().stream().filter(npc -> npc.getWorldLocation().distanceTo(sourceWorldPoint) == 0).findAny();        Actor target = projectile.getInteracting();        String sourcePointString = "x: " + sourceWorldPoint.getX() + " y: " + sourceWorldPoint.getY();        String destPointString = "x: " + destWorldPoint.getX() + ", y: " + destWorldPoint.getY();        String targetString = target instanceof Player ? ("Player(" + (target.getName() + " - " + destPointString + ")")) : target instanceof NPC ?                ("Npc(" + (target.getName() + " - " + destPointString + ")")) : ("Unknown(" + destPointString + ")");        if (sourcePlayer.isPresent() && sourceNpc.isEmpty()) {            if (!showPlayers.isSelected()) return;            addEntry(earlyProjectile, dynamicInfo, "Player(" + sourcePlayer.get().getName() + " - " + sourcePointString + ") -> " + targetString + "   ");        } else if (sourceNpc.isPresent() && sourcePlayer.isEmpty()) {            if (!showNpcs.isSelected()) return;            addEntry(earlyProjectile, dynamicInfo, "Npc(" + sourceNpc.get().getName() + " - " + sourcePointString + ") -> " + targetString + "   ");        } else {            if (!showUnknowns.isSelected()) return;            addEntry(earlyProjectile, dynamicInfo, "Unknown(" + sourcePointString + ") -> " + targetString + "   ");        }    }    private String formatIncompleteProjectileEntry(EarlyProjectileInfo earlyProjectileInfo,                                             DynamicProjectileInfo dynamicProjectileInfo) {        return "IncompleteProjectile(id = " + earlyProjectileInfo.id                + ", startHeight = " + earlyProjectileInfo.startHeight                + ", endHeight = " + earlyProjectileInfo.endHeight                + ", delay = " + earlyProjectileInfo.delay                + ", angle = " + earlyProjectileInfo.angle                + ", distOffset = " + earlyProjectileInfo.distanceOffset                + ") - Distance: " + dynamicProjectileInfo.distance + ", flight duration: " + dynamicProjectileInfo.flightDuration;    }    private String formatFullProjectileEntry(EarlyProjectileInfo earlyProjectileInfo,                                             DynamicProjectileInfo dynamicProjectileInfo,                                             int stepMultiplier) {        final int duration = dynamicProjectileInfo.flightDuration;        final int distance = dynamicProjectileInfo.distance;        final int lengthAdjustment = duration - (distance * stepMultiplier);        return "Projectile(id = " + earlyProjectileInfo.id + ", startHeight = " + earlyProjectileInfo.startHeight + ", endHeight = " + earlyProjectileInfo.endHeight                + ", delay = " + earlyProjectileInfo.delay + ", angle = " + earlyProjectileInfo.angle + ", lengthAdjustment = " + lengthAdjustment                + ", distOffset = " + earlyProjectileInfo.distanceOffset + ", stepMultiplier = " + stepMultiplier + ")";    }    @Override    public void open() {        eventBus.register(this);        super.open();    }    @Override    public void close() {        super.close();        inspectedProjectiles.clear();        identifiedProjectiles.clear();        trackedProjectiles.clear();        tracker.removeAll();        eventBus.unregister(this);    }    @EqualsAndHashCode    private static class DynamicProjectileInfo {        private final LocalPoint startPoint;        private final LocalPoint endPoint;        private final int flightDuration;        private final int distance;        DynamicProjectileInfo(LocalPoint startPoint, LocalPoint endPoint, int flightDuration) {            this.startPoint = startPoint;            this.endPoint = endPoint;            this.flightDuration = flightDuration;            this.distance = Math.max(Math.abs(startPoint.getSceneX() - endPoint.getSceneX()), Math.abs(startPoint.getSceneY() - endPoint.getSceneY()));        }    }    @Data    private static class EarlyProjectileInfo {        private final int id;        private final int startHeight;        private final int endHeight;        private final int angle;        private final int distanceOffset;        private final int delay;    }}