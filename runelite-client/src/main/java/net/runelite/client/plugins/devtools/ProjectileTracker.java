package net.runelite.client.plugins.devtools;import lombok.Data;import lombok.EqualsAndHashCode;import lombok.Getter;import net.runelite.api.*;import net.runelite.api.coords.LocalPoint;import net.runelite.api.coords.WorldPoint;import net.runelite.api.events.ProjectileMoved;import java.util.*;import java.util.List;/** * @author Kris | 22/10/2021 */public class ProjectileTracker {    private final Set<Projectile> inspectedProjectiles = Collections.synchronizedSet(new HashSet<>());    private final Map<EarlyProjectileInfo, List<DynamicProjectileInfo>> trackedProjectiles = Collections.synchronizedMap(new HashMap<>());    private final Map<EarlyProjectileInfo, Integer> identifiedProjectiles = Collections.synchronizedMap(new HashMap<>());    void clearCache() {        inspectedProjectiles.clear();        trackedProjectiles.clear();        identifiedProjectiles.clear();    }    void submitProjectileMoved(Client client, ProjectileMoved event, QuadConsumer<EarlyProjectileInfo, DynamicProjectileInfo, String, String> consumer) {        Projectile projectile = event.getProjectile();        /* No need to run the calculations for every tick that the projectile moves - just the first, on spawn, is enough. */        if (!inspectedProjectiles.add(projectile)) return;        LocalPoint destinationPoint = event.getPosition();        int localSrcPointX = projectile.getX1();        int localSrcPointY = projectile.getY1();        LocalPoint sourcePoint = new LocalPoint(localSrcPointX, localSrcPointY);        int tileHeight = Perspective.getTileHeight(client, sourcePoint, projectile.getFloor());        int currentCycle = client.getGameCycle();        int startCycle = projectile.getStartMovementCycle() - currentCycle;        int endCycle = projectile.getEndCycle() - currentCycle;        int id = projectile.getId();        int startHeight = -((projectile.getHeight() - tileHeight) / 4);        int endHeight = projectile.getEndHeight() / 4;        int angle = projectile.getSlope();        int distOffset = projectile.getStartHeight();        EarlyProjectileInfo earlyProjectile = new EarlyProjectileInfo(id, startHeight, endHeight, angle, distOffset, startCycle);        DynamicProjectileInfo dynamicInfo = new DynamicProjectileInfo(sourcePoint, destinationPoint, endCycle - startCycle);        WorldPoint sourceWorldPoint = WorldPoint.fromLocal(client, sourcePoint);        WorldPoint destWorldPoint = WorldPoint.fromLocal(client, destinationPoint);        Optional<Player> sourcePlayer = client.getPlayers().stream().filter(player -> player.getWorldLocation().distanceTo(sourceWorldPoint) == 0).findAny();        Optional<NPC> sourceNpc = client.getNpcs().stream().filter(npc -> npc.getWorldLocation().distanceTo(sourceWorldPoint) == 0).findAny();        Actor target = projectile.getInteracting();        String sourcePointString = "x: " + sourceWorldPoint.getX() + " y: " + sourceWorldPoint.getY();        String destPointString = "x: " + destWorldPoint.getX() + ", y: " + destWorldPoint.getY();        String targetString = target instanceof Player ? ("Player(" + (target.getName() + " - " + destPointString + ")")) : target instanceof NPC ?                ("Npc(" + (target.getName() + " - " + destPointString + ")")) : ("Unknown(" + destPointString + ")");        String projectileText = getProjectileText(earlyProjectile, dynamicInfo);        if (sourcePlayer.isPresent() && sourceNpc.isEmpty()) {            consumer.accept(earlyProjectile, dynamicInfo, "Player(" + sourcePlayer.get().getName() + " - " + sourcePointString + ") -> " + targetString,                    projectileText);        } else if (sourceNpc.isPresent() && sourcePlayer.isEmpty()) {            consumer.accept(earlyProjectile, dynamicInfo, "Npc(" + sourceNpc.get().getName() + " - " + sourcePointString + ") -> " + targetString,                    projectileText);        } else {            consumer.accept(earlyProjectile, dynamicInfo, "Unknown(" + sourcePointString + ") -> " + targetString, projectileText);        }    }    String getProjectileText(EarlyProjectileInfo earlyProjectile, DynamicProjectileInfo dynamicInfo) {        Integer identifiedProjectileDuration = identifiedProjectiles.get(earlyProjectile);        if (identifiedProjectileDuration == null) {            /* Check if this projectile already has information on it, if so, we can provide in-depth values for that projectile. */            List<DynamicProjectileInfo> existingDynamicInfos = trackedProjectiles.computeIfAbsent(earlyProjectile, k -> new ArrayList<>());            Optional<DynamicProjectileInfo> diffDistanceInfo =                    existingDynamicInfos.stream().filter(dynamicProjectileInfo -> dynamicProjectileInfo.distance != dynamicInfo.distance).findFirst();            existingDynamicInfos.add(dynamicInfo);            if (diffDistanceInfo.isPresent()) {                DynamicProjectileInfo existingDynamicInfo = diffDistanceInfo.get();                final int distanceDiff = dynamicInfo.distance - existingDynamicInfo.distance;                final int durationDiff = dynamicInfo.flightDuration - existingDynamicInfo.flightDuration;                final int durationPerTileDistance = Math.abs(durationDiff / distanceDiff);                identifiedProjectiles.put(earlyProjectile, durationPerTileDistance);                /* Since identified projectile now tracks this, we no longer need to keep a hold of these projectiles. */                trackedProjectiles.remove(earlyProjectile);                return formatFullProjectileEntry(earlyProjectile, dynamicInfo, durationPerTileDistance);            }            return formatIncompleteProjectileEntry(earlyProjectile, dynamicInfo);        }        return formatFullProjectileEntry(earlyProjectile, dynamicInfo, identifiedProjectileDuration);    }    private String formatIncompleteProjectileEntry(EarlyProjectileInfo earlyProjectileInfo, DynamicProjectileInfo dynamicProjectileInfo) {        return "IncompleteProjectile(id = " + earlyProjectileInfo.getId() + ", startHeight = " + earlyProjectileInfo.getStartHeight() + ", endHeight = " + earlyProjectileInfo.getEndHeight() + ", delay = " + earlyProjectileInfo.getDelay() + ", angle = " + earlyProjectileInfo.getAngle() + ", distOffset = " + earlyProjectileInfo.getDistanceOffset() + ") - Distance: " + dynamicProjectileInfo.getDistance() + ", flight duration: " + dynamicProjectileInfo.getFlightDuration();    }    private String formatFullProjectileEntry(EarlyProjectileInfo earlyProjectileInfo, DynamicProjectileInfo dynamicProjectileInfo, int stepMultiplier) {        final int duration = dynamicProjectileInfo.getFlightDuration();        final int distance = dynamicProjectileInfo.getDistance();        final int lengthAdjustment = duration - (distance * stepMultiplier);        return "Projectile(id = " + earlyProjectileInfo.getId() + ", startHeight = " + earlyProjectileInfo.getStartHeight() + ", endHeight = " + earlyProjectileInfo.getEndHeight() + ", delay = " + earlyProjectileInfo.getDelay() + ", angle = " + earlyProjectileInfo.getAngle() + ", lengthAdjustment = " + lengthAdjustment + ", distOffset = " + earlyProjectileInfo.getDistanceOffset() + ", stepMultiplier = " + stepMultiplier + ")";    }    @EqualsAndHashCode    @Getter    static class DynamicProjectileInfo {        private final LocalPoint startPoint;        private final LocalPoint endPoint;        private final int flightDuration;        private final int distance;        DynamicProjectileInfo(LocalPoint startPoint, LocalPoint endPoint, int flightDuration) {            this.startPoint = startPoint;            this.endPoint = endPoint;            this.flightDuration = flightDuration;            this.distance = Math.max(Math.abs(startPoint.getSceneX() - endPoint.getSceneX()), Math.abs(startPoint.getSceneY() - endPoint.getSceneY()));        }    }    @Data    static class EarlyProjectileInfo {        private final int id;        private final int startHeight;        private final int endHeight;        private final int angle;        private final int distanceOffset;        private final int delay;    }    @FunctionalInterface    public interface QuadConsumer<X, Y, T, U> {        void accept(X x, Y y, T t, U u);    }}